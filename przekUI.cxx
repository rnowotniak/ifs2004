// generated by Fast Light User Interface Designer (fluid) version 1.0105

#include "przekUI.h"

inline void przekUI::cb_P_i(Fl_Slider*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_P(Fl_Slider* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_P_i(o,v);
}

inline void przekUI::cb_c_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_c(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_c_i(o,v);
}

inline void przekUI::cb_f_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_f(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_f_i(o,v);
}

inline void przekUI::cb_theta_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_theta(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_theta_i(o,v);
}

inline void przekUI::cb_fi_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_fi(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_fi_i(o,v);
}

inline void przekUI::cb_r_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_r(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_r_i(o,v);
}

inline void przekUI::cb_s_i(Fl_Value_Input*, void* v) {
  ((przekUI*)v)->do_callback();
}
void przekUI::cb_s(Fl_Value_Input* o, void* v) {
  ((przekUI*)(o->parent()->parent()->user_data()))->cb_s_i(o,v);
}

przekUI::przekUI(int x, int y, int w, int h, const char *label ) : Fl_Group(x, y, w, h, label) {
    { Fl_Group* o = new Fl_Group(0 + x, 0 + y, 210, 70);
      o->box(FL_THIN_DOWN_FRAME);
      { Fl_Slider* o = P = new Fl_Slider(6 + x, 53 + y, 198, 12);
        o->tooltip("Prawdopodobienstwo");
        o->type(3);
        o->selection_color((Fl_Color)89);
        o->maximum(100);
        o->step(1);
        o->value(20);
        o->callback((Fl_Callback*)cb_P, (void*)(this));
        o->align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE);
      }
      { Fl_Box* o = new Fl_Box(3 + x, 2 + y, 66, 14, "Translacje");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(67 + x, 2 + y, 66, 14, "Obroty");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(142 + x, 2 + y, 66, 14, "Skalowania");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(10 + x, 15 + y, 16, 13, "x");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(45 + x, 15 + y, 16, 13, "y");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(78 + x, 15 + y, 16, 13, "q");
        o->labelfont(12);
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(112 + x, 15 + y, 16, 13, "f");
        o->labelfont(12);
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(154 + x, 15 + y, 16, 13, "r");
        o->labelsize(10);
      }
      { Fl_Box* o = new Fl_Box(184 + x, 15 + y, 16, 13, "s");
        o->labelsize(10);
      }
      { Fl_Value_Input* o = c = new Fl_Value_Input(3 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-100);
        o->maximum(100);
        o->step(0.01);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_c, (void*)(this));
      }
      { Fl_Value_Input* o = f = new Fl_Value_Input(39 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-100);
        o->maximum(100);
        o->step(0.01);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_f, (void*)(this));
      }
      { Fl_Value_Input* o = theta = new Fl_Value_Input(73 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-360);
        o->maximum(360);
        o->step(1);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_theta, (void*)(this));
      }
      { Fl_Value_Input* o = fi = new Fl_Value_Input(105 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-360);
        o->maximum(360);
        o->step(1);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_fi, (void*)(this));
      }
      { Fl_Value_Input* o = r = new Fl_Value_Input(144 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-10);
        o->maximum(10);
        o->step(0.1);
        o->value(1);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_r, (void*)(this));
      }
      { Fl_Value_Input* o = s = new Fl_Value_Input(178 + x, 29 + y, 31, 20);
        o->labelsize(10);
        o->minimum(-10);
        o->maximum(10);
        o->step(0.1);
        o->value(1);
        o->textsize(10);
        o->callback((Fl_Callback*)cb_s, (void*)(this));
      }
      o->end();
  }
  numer = przekUI::ostatni++;
}

void przekUI::Resetuj() {
  Ustaw(Macierz());
}

void przekUI::Ustaw(const Macierz &M) {
  float x;

c->value(M.c);
f->value(M.f);

if (M.a == 0 && M.d == 0)
   x = 0;
else if ((x = (M.d<0?-1.0:1.0) * 180.0 * acos(M.a / hypot(M.a, M.d)) / PI) == EDOM)
   x = 0;
fi->value(x);

if (M.b == 0 && M.e == 0)
   x = 0;
else if ((x = (M.b>0?-1.0:1.0) * 180.0 * acos(M.e / hypot(M.b, M.e)) / PI) == EDOM)
   x = 0;
theta->value(x);

r->value(hypot(M.a, M.d));
s->value(hypot(M.b, M.e));
}
unsigned przekUI::ostatni = 0;
